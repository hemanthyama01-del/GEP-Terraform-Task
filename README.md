# Azure Terraform Infrastructure

Production-ready, modular Terraform infrastructure for Azure — featuring a reusable VNET module, multi-environment deployments (dev / prod), remote state, GitHub Actions CI/CD, pre-commit hooks, terraform-docs automation, and Terratest integration tests.

---

## Repository Layout

```
.
├── modules/
│   └── vnet/                   # Reusable VNET module
│       ├── main.tf
│       ├── variables.tf
│       ├── outputs.tf
│       ├── versions.tf
│       └── README.md           # Auto-generated by terraform-docs
│
├── environments/
│   ├── dev/                    # Development environment
│   │   ├── main.tf             # VNET module + VM + Storage Account
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── locals.tf           # Naming convention helpers
│   │   ├── providers.tf
│   │   ├── backend.tf          # Azure remote state
│   │   └── terraform.tfvars    # Non-sensitive variable values
│   └── prod/                   # Production environment
│       └── ...
│
├── tests/
│   ├── go.mod
│   └── vnet_test.go            # Terratest integration + unit tests
│
├── .github/
│   └── workflows/
│       └── terraform.yml       # CI/CD pipeline
│
├── .pre-commit-config.yaml     # Pre-commit hooks (fmt, validate, tflint, trivy, docs)
├── .terraform-docs.yml         # terraform-docs configuration
├── .tflint.hcl                 # TFLint configuration
├── .gitignore
└── README.md
```

---

## Prerequisites

| Tool | Minimum Version | Install |
|------|-----------------|---------|
| Terraform | 1.5.0 | [terraform.io](https://developer.hashicorp.com/terraform/downloads) |
| Azure CLI | 2.55.0 | [learn.microsoft.com](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli) |
| Go | 1.21 | [go.dev](https://go.dev/dl/) (tests only) |
| pre-commit | 3.x | `pip install pre-commit` |
| terraform-docs | 0.17.x | [terraform-docs.io](https://terraform-docs.io/user-guide/installation/) |
| tflint | 0.50.x | [tflint docs](https://github.com/terraform-linters/tflint#installation) |
| trivy | 0.50.x | [aquasec.com](https://aquasecurity.github.io/trivy/latest/getting-started/installation/) |

---

## Quick Start

### 1 — Bootstrap Remote State Storage

Before first `terraform init`, create the Azure Storage Account that will store Terraform state.  
Run this **once per environment** (replace values as needed):

```bash
# Dev
az group create --name rg-tfstate-dev   --location eastus
az storage account create \
    --name sttfstatedev001 \
    --resource-group rg-tfstate-dev \
    --sku Standard_LRS \
    --min-tls-version TLS1_2
az storage container create \
    --name tfstate \
    --account-name sttfstatedev001

# Prod — same pattern with prod names
```

### 2 — Set Credentials

```bash
export ARM_CLIENT_ID="<service-principal-app-id>"
export ARM_CLIENT_SECRET="<service-principal-secret>"
export ARM_TENANT_ID="<aad-tenant-id>"
export ARM_SUBSCRIPTION_ID="<subscription-id>"

# SSH key for the VM (never commit this)
export TF_VAR_admin_ssh_public_key="$(cat ~/.ssh/id_rsa.pub)"
```

Alternatively, use an OIDC-based Federated Identity for GitHub Actions (recommended — no long-lived secrets).

### 3 — Deploy Dev

```bash
cd environments/dev
terraform init
terraform plan
terraform apply
```

### 4 — Deploy Prod

```bash
cd environments/prod
terraform init
terraform plan
terraform apply
```

---

## Naming Convention

All resources follow the pattern:

```
<project>-<environment>-<region_short>-<resource_type>
```

Examples:

| Resource | Name |
|----------|------|
| Resource Group | `myapp-dev-eus-rg` |
| Virtual Network | `myapp-dev-eus-vnet` |
| Subnet | `myapp-dev-eus-snet-app` |
| NSG | `myapp-dev-eus-nsg-app` |
| VM | `myapp-dev-eus-vm` |
| Storage Account | `stmyappdeveus001xxxx` |

---

## Tagging Strategy

Every resource created by this repository inherits the following tags:

| Tag | Purpose |
|-----|---------|
| `environment` | Deployment stage (dev / prod) |
| `project` | Workload / application name |
| `owner` | Responsible team |
| `cost_center` | Billing allocation code |
| `managed_by` | Always `"terraform"` |
| `last_updated` | Date of last `terraform apply` |

---

## CI/CD Pipeline

The GitHub Actions workflow (`.github/workflows/terraform.yml`) implements:

```
Pull Request             Push to main
─────────────────        ────────────────────────────────────
lint (fmt check)    →    lint → validate → apply (w/ approval)
    ↓
validate (dev+prod)
    ↓
plan (dev+prod)
  posts diff to PR
```

### Required GitHub Secrets

| Secret | Description |
|--------|-------------|
| `AZURE_CLIENT_ID` | Service principal / OIDC app ID |
| `AZURE_TENANT_ID` | Azure AD tenant ID |
| `AZURE_SUBSCRIPTION_ID` | Target subscription |
| `VM_SSH_PUBLIC_KEY` | SSH public key for VM admin user |

### Manual Approval

The `apply` job targets GitHub Environments named `dev-apply` and `prod-apply`.  
Configure **Required reviewers** on the `prod-apply` environment in:  
**GitHub → Repository Settings → Environments → prod-apply → Required reviewers**

---

## Pre-commit Hooks

Install once:

```bash
pip install pre-commit
pre-commit install
```

Hooks run automatically on every `git commit`:

- `terraform fmt` — format check
- `terraform validate` — syntax / type validation  
- `tflint` — Terraform linting + Azure-specific rules
- `trivy` — security scanning for HIGH/CRITICAL issues
- `terraform-docs` — auto-regenerate module `README.md` files
- `detect-secrets` — prevent accidental credential commits

Run all hooks manually:

```bash
pre-commit run --all-files
```

---

## Tests

```bash
cd tests

# Syntax / validate only (no Azure credentials needed)
go test -v -run TestVnetModuleValidate ./...
go test -v -run TestVnetModuleInvalidCIDRFails ./...

# Full integration test (deploys + destroys real Azure resources)
go test -v -timeout 30m -run TestVnetModuleIntegration ./...

# Skip integration in CI
SKIP_INTEGRATION_TESTS=true go test -v ./...
```

---

## Module Reference

See [modules/vnet/README.md](modules/vnet/README.md) for auto-generated input/output documentation.

---

## Security Considerations

- All storage accounts enforce `TLS1_2` and default-deny network rules.
- VMs use SSH key authentication only; password auth is disabled.
- VM identities use System-Assigned Managed Identity (no stored credentials).
- NSGs apply explicit deny-all rules at the lowest priority.
- Terraform state is stored in Azure Blob with encryption at rest.
- Pre-commit hooks scan for secrets before every commit.
- DDoS protection is configurable per environment.

---

## Contributing

1. Fork and create a feature branch.
2. Run `pre-commit run --all-files` before pushing.
3. Open a Pull Request — the CI pipeline will run `fmt`, `validate`, and `plan` automatically.
4. After approval, merge to `main` to trigger the `apply` pipeline (requires manual approval for prod).
